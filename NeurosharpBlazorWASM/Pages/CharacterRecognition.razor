@page "/characterrecognition"
@using System.Text.Json
@using NeurosharpBlazorWASM.Helpers
@inject IJSRuntime JsRuntime;

<MatDialogContent>
    <SignaturePad @ref="signature" MinWidth="@size" MinHeight="@size" MaxWidth="@size" MaxHeight="@size" OnSignatureChange="@(() => SignatureChangeEvent())">
        <SignaturePadFooter FooterDirective="@("Draw a letter or number")" />
    </SignaturePad>  
</MatDialogContent>
<MatDialogActions>
</MatDialogActions>

<div>
    <select @bind="currentChar">
        @foreach (string s in possibleChars)
        {
            <option value="@s">@s</option>
        }
    </select>
</div>
<div>
    <input type="button" value="Download" id="submit-btn" onclick="@(() => DownloadDataPoint())"/>
</div>

<canvas @ref="_canvasReference" style="display: none" width="@size" height="@size"></canvas>

@code
{
    int size = 192;
    bool dialogIsOpen = false;
    List<string> possibleChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".Select(x => x.ToString()).ToList();
    string currentChar;

    SignaturePad signature;
    Network _network;
    Network _scalingNetwork;
    ElementReference _canvasReference;
    ElementReference _imageReference;

    Vector<double> currentImageValue;

    private static Func<object, Task> DoImageParsing;

    protected override async Task OnInitializedAsync()
    {
    //_network = NetworkStorage.Networks["CharacterRecognition"];
        await base.OnInitializedAsync();
        DoImageParsing = ParseImageData;
        
        _scalingNetwork = new Network(size/4);
        MaxPoolingLayer layer = new MaxPoolingLayer(poolSize: 4, stride: 4);
        layer.SetFilterCount(1);
        _scalingNetwork.Layers.Add(layer);
    }

    public async void DownloadDataPoint()
    {
        await DownloadFile();
        signature.Clear();
    }

    public async void SignatureChangeEvent()
    {
        string imageURL = await signature.ToDataURL();
        await JsRuntime.InvokeAsync<object>("image_processor.ParseCanvas", imageURL, _canvasReference);
    }

    public async Task ParseImageData(object data)
    {
        Vector<double> rawImageVector = Vector<double>.Build.DenseOfEnumerable(
            ((JsonElement)data).EnumerateArray().Select(x => double.Parse(x.ToString()) / 255.0)
        );
        
        currentImageValue = _scalingNetwork.Predict(rawImageVector);
        //string pixelVals = string.Join(",", currentImageValue);
        //Console.WriteLine(pixelVals);
    }

    [JSInvokable]
    public static async void ReceiveImageData(object data)
    {
        await DoImageParsing.Invoke(data);
    }
    
    public async Task DownloadFile()
    {
        string text = string.Join(",", currentImageValue);;
        byte[] bytes = System.Text.Encoding.UTF8.GetBytes(text);
        await FileUtil.SaveAs(JsRuntime, currentChar + "_.txt", bytes);
    }
}
